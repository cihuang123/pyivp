#include "../lib_geometry/XYSegList.h"
#include <pybind11/stl.h>
#include <pybind11/pybind11.h>
namespace py = pybind11;
void init_XYSegList(py::module &m) {
    py::class_<XYSegList>(m, "XYSegList")
    .def(py::init())
    .def("add_vertex", py::overload_cast<const XYPoint&, std::string>(&XYSegList::add_vertex), "add vertex with a vertex\nInput: XYPoint&, vprop")
    .def("add_vertex", py::overload_cast<double, double, double, std::string>(&XYSegList::add_vertex), "add vertex with x y\nInput: x, y, z, vprop")
    .def("mod_vertex", &XYSegList::mod_vertex, "modify the vertex\nInput: ix, x, y, z, vprop")
    .def("alter_vertex", &XYSegList::alter_vertex, "fing the existing vertex that is closest ,and replace it.\nInput: x, y, z, s")
    .def("delete_vertex", py::overload_cast<double, double>(&XYSegList::delete_vertex), "given a new vertex .find the existing vertex that is closet,and delete it\nInput: x, y")
    .def("delete_vertex", py::overload_cast<unsigned int>(&XYSegList::delete_vertex), "given a valid vertex index,delete that vertex from the SegList.\nInput: ix")
    .def("insert_vertex", &XYSegList::insert_vertex, "Given a new vertex, find the existing segment that is closest, and add the vertex between points\nInput: x, y, z, s")
    .def("set_edge_tags", &XYSegList::set_edge_tags, "set edgetags using EdgeTagSet function\nInput: input: (EdgeTagSet) v")
    .def("pop_last_vertex", &XYSegList::pop_last_vertex, "Remove the last vertex")
    .def("clear", &XYSegList::clear, "clear it")
    .def("shift_horz", &XYSegList::shift_horz, py::arg("val"), "shift x(horz) as give value\nInput: shift value")
    .def("shift_vert", &XYSegList::shift_vert, py::arg("val"), "shift y(vert) as give value\nInput: shift value")
    .def("grow_by_pct", &XYSegList::grow_by_pct, py::arg("pct"), "grow_by_pct\nInput: pct\nReturn:\n new_x=(x-centroid_x)*pct\n new_y=(y-centroid_y)*pct")
    .def("grow_by_amt", &XYSegList::grow_by_pct, py::arg("amt"), "grow_by_amt\nReturn:\n degval=angle between x, y & centroid_x, centroid_y\n radang=degToRadians(degval)\n telta_x=sin(radang)*amt,telta_y=cos(radang)*amt\n new_x=centroid_x+telta_x,new_x=y=centroid_y+telta_y")
    .def("apply_snap", &XYSegList::apply_snap, py::arg("snapval"), "use function snapToStep on x, y\nReturn:\nif snapval<=0\n  original_x, y\nelse\n  new_val = orig_value /snapval\n  if new_val<0\n    itemp=new_val-0.5 \n  else\n    itemp=new_val+0.5\n  new_val_x, y= (double)itemp * step")
    .def("rotate", py::overload_cast<double>(&XYSegList::rotate), py::arg("degree"), "depends on the value of degrees and cx, cy , caculate it and produce new XYSegList\nInput: degrees")
    .def("rotate", py::overload_cast<double, double, double>(&XYSegList::rotate), py::arg("degrees"), py::arg("cx"), py::arg("cy"), "depends on the value of degrees and cx, cy , caculate it and produce new XYSegList\nInput: degrees, cx, cy")
    .def("reverse", &XYSegList::reverse,"reverse the result ( head-->tail ,tail-->head )")
    .def("new_center", &XYSegList::new_center, py::arg("x"), py::arg("y"), "Setting new  center as given points\nInput: new_cx, new_cy")
    .def("new_centroid", &XYSegList::new_centroid, py::arg("x"), py::arg("y"), "Setting new  centroid as given points\nInput: new_cx, new_cy")
    .def("is_clockwise", &XYSegList::is_clockwise, "Determine if the ordering of points in the internal vector of stored points constitutes a clockwise walk  around the center.\nReturn: true if all points  can be a clockwise walk, else return false ")
    .def("valid", &XYSegList::valid, "testing the SegList is valid or not \nReturn: return false if it is empty,else return true")
    .def("size", &XYSegList::size, "return the size of the SegLsit\nReturn: size of the SegLsit")
    .def("get_vx", &XYSegList::get_vx, "get_vx\nInput: i\nReturn: x value")
    .def("get_vy", &XYSegList::get_vy, "get_vy\nInput: i\nReturn: y value")
    .def("get_vz", &XYSegList::get_vz, "get_vz\nInput: i\nReturn: z value")
    .def("get_vprop", &XYSegList::get_vprop, "get the vprop of index given from SegList\nInput: i\nReturn: vprop")
    .def("get_center_x", &XYSegList::get_center_x, "Return the mid point between the extreme x low, high\nReturn: mid point of x")
    .def("get_center_y", &XYSegList::get_center_y, "Return the mid point between the extreme y low, high\nReturn: mid point of y")
    .def("get_centroid_x", &XYSegList::get_centroid_x, "Return the x center of mass of all points\nReturn: x center of mass")
    .def("get_centroid_y", &XYSegList::get_centroid_y, "Return the y center of mass of all points\nReturn: y center of mass")
    .def("get_min_x", &XYSegList::get_min_x, "Return the min of the x values\nReturn: min point of x")
    .def("get_max_x", &XYSegList::get_max_x, "Return the max of the x values\nReturn: max point of x")
    .def("get_min_y", &XYSegList::get_min_y, "Return the min of the y values\nReturn: min point of y")
    .def("get_max_y", &XYSegList::get_max_y, "Return the max of the y values\nReturn: max point of y")
    .def("get_avg_x", &XYSegList::get_avg_x, "Return the avg of the x values\nReturn: average value of x")
    .def("get_avg_y", &XYSegList::get_avg_y, "Return the avg of the y values\nReturn: average value of y")
    .def("dist_to_point", &XYSegList::dist_to_point, py::arg("x"), py::arg("y"), "find the closest distance from the given point to any point on any segment.\nInput: x, y\nReturn: the closest distance value")
    .def("dist_to_ctr", &XYSegList::dist_to_ctr, py::arg("x"), py::arg("y"), "find the distance between the given point and center\nInput: x, y\nReturn: distance")
    .def("max_dist_to_ctr", &XYSegList::max_dist_to_ctr, "Return the maximum distance between the center and any one of the vertices in the SegList.\nReturn: maximum distance between center and others")
    .def("segs_cross", &XYSegList::segs_cross, py::arg("loop")=true, "Determine if any two segments intersect one another We exclude from consideration any two segments that share a vertex. If the result is false, then this set of line segments should form a polygon, although not necessarily a convex polygon\nReturn: false if size<=3 or form a polygon")
    .def("length", &XYSegList::length, "Determine the overall length between the first and the last point-distance in the X-Y Plane only\nReturn: all length between the first point and last point")
    .def("get_spec", py::overload_cast<unsigned int>(&XYSegList::get_spec, py::const_), "you can see SegList with this function\nWe set the vertex precision to be at the integer by default.\nInput: precision\nReturn: content of XYSegList")
    .def("get_spec", py::overload_cast<std::string>(&XYSegList::get_spec, py::const_), "you can see SegList with this function\nInput: param\nReturn: content of XYSegList")
    .def("get_spec", py::overload_cast<unsigned int, std::string>(&XYSegList::get_spec, py::const_), "you can see SegList with this function\nWe set the vertex precision to be at the integer by default.\nInput: precision,param\nReturn: content of XYSegList")
    .def("get_spec_pts", &XYSegList::get_spec_pts, py::arg("vertex_prec")=1, "We set the vertex precision to be at the integer by default.\nInput: precision\nReturn: content of XYSegList")
    .def("get_spec_pts_label", &XYSegList::get_spec_pts_label, py::arg("vertex_prec")=1, "Get a string specification of just the points and label.\nInput: precision\nReturn: result of XYSegList")
    .def("get_spec_inactive", &XYSegList::get_spec_inactive, "In cases where we know the polygon spec is created simply to 'erase' a previous poly with the same label, just generate a concise spec with a trivial convext poly.\nReturn: pts={0,0:9,0:0,9},active=false")
    .def("closest_vertex", &XYSegList::closest_vertex, "Find the existing vertex that is closest to the given point.\nInput: x, y\nReturn: The index of the vertex that is closest. A return of zero indicates either vertex index=0, or the SegList is empty. This can be discerned by the caller by checking the size() of the SegList.")
    .def("closest_segment", &XYSegList::closest_segment, "Find the existing segment that is closest to the given point. it will the 'leading' index of the segment.\nInput: x, y, check_implied_seg\nReturn: index of closest segement -1 ")
    .def("get_edge_tags", &XYSegList::get_edge_tags, "get_edge_tags\nReturn: edge_tags")
    ;
}